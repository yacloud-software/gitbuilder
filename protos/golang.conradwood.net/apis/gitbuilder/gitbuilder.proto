syntax = "proto3";

package gitbuilder;
option java_package = "net.conradwood.apis.gitbuilder";
import "golang.conradwood.net/apis/common/common.proto";

message BuildRequest {
  string GitURL=1; // the git repository url
  repeated string FetchURLS=2; // any fetch urls that need to be applied before build (for gerrit patches)
  string CommitID=3; // the commit id to build
  uint64 BuildNumber=4; // the buildnumber for this build
  uint64 RepositoryID=5; // the build scripts might use this
  string RepoName=6; // the buildscripts might use this
  string ArtefactName=7; // the upload script uses this to upload to buildrepo
  repeated string ExcludeBuildScripts=8; // do not run these rules, despite what is configured in the repository
  repeated string IncludeBuildScripts=9; // do run these rules, in addition to what is configured in the repository
  bool RequiresDeepClone=10; // if true, run git clone with all commits and branches
}
message BuildResponse {
  bytes Stdout=1;// the output of the build process streamed back
  bool Complete=2; // if true this is the last message
  string ResultMessage=3; // a human-readable message
  bool Success=4; // if true the build succeeded
  string LogMessage=5; // the builder sends back the logmessage of the commit it built
}
message LocalRepo {
  string URL=1;
  repeated string FetchURLs=2;
  bool InUse=3;
  string WorkDir=4;
  uint32 Created=5;
  uint32 Released=6;
}
message LocalRepoList {
  repeated LocalRepo Repos=1;
}
message BuildScriptList {
  repeated string Names=1;
}
// this is doing the actual build. It checksout a git repository, runs the build
// and uploads the artefacts
service GitBuilder {
  // build something. Note that this RPC might take several minutes to complete
  rpc Build(BuildRequest) returns (stream BuildResponse);
  // get information about the repos on disk
  rpc GetLocalRepos(common.Void) returns (LocalRepoList);
  // get "known" build scripts
  rpc GetBuildScripts(common.Void) returns (BuildScriptList);
}


